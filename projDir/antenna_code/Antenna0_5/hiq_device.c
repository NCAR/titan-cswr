/************************************************************************
*  File: hiq_diag.c
*
*  Sample user-mode diagnostics application for accessing HIQ
*  devices via a Kernel PlugIn driver using WinDriver's API.
*  Code was generated by DriverWizard v9.20.
*
*  Jungo Confidential. Copyright (c) 2009 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include <stdio.h>
#include <conio.h>
#include "wdc_defs.h"
#include "wdc_lib.h"
#include "utils.h"
#include "status_strings.h"
#include "samples/shared/diag_lib.h"
#include "samples/shared/wdc_diag_lib.h"
#include "samples/shared/pci_regs.h"
#include "hiq_device.h"
#include "hiq_lib.h"
#include "hiq_hardware.h"
#include "hiqutil.h"

/*************************************************************
  General definitions
 *************************************************************/
/* Error messages display */
#define HIQ_ERR printf

/*************************************************************
  Global variables
 *************************************************************/
/* User's input command */
//static CHAR gsInput[256];

/* --------------------------------------------------
    HIQ configuration registers information
   -------------------------------------------------- */
/* Configuration registers information array */
const WDC_REG gHIQ_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID", "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID", "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD", "Revision ID & Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC", "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC", "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN", "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT", "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR", "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST", "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0", "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1", "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2", "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3", "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4", "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5", "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS", "CardBus CIS Pointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID", "Sub-system Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID", "Sub-system Device ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM", "Expansion ROM Base Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP", "New Capabilities Pointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN", "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN", "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT", "Minimum Required Burst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT", "Maximum Latency" },
    };
#define HIQ_CFG_REGS_NUM sizeof(gHIQ_CfgRegs) / sizeof(WDC_REG)
/* TODO: For read-only or write-only registers, change the direction field of
         the relevant registers in gHIQ_CfgRegs to WDC_READ or WDC_WRITE. */
/* NOTE: You can define additional configuration registers in gHIQ_CfgRegs. */
const WDC_REG *gpHIQ_CfgRegs = gHIQ_CfgRegs;

/* -----------------------------------------------
    HIQ run-time registers information
   ----------------------------------------------- */
/* Run-time registers information array */
const WDC_REG gHIQ_Regs[] = {
    { HIQ_INTCSR_SPACE, HIQ_INTCSR_OFFSET, WDC_SIZE_32, WDC_READ_WRITE, "INTCSR", "" },
    { HIQ_DMACSR0_SPACE, HIQ_DMACSR0_OFFSET, WDC_SIZE_8, WDC_READ_WRITE, "DMACSR0", "" },
    { HIQ_DMAPR0_SPACE, HIQ_DMAPR0_OFFSET, WDC_SIZE_32, WDC_READ_WRITE, "DMAPR0", "" },
    { HIQ_DMAMODE0_SPACE, HIQ_DMAMODE0_OFFSET, WDC_SIZE_32, WDC_READ_WRITE, "DMAMODE0", "" },
    { HIQ_FIFOCLR_SPACE, HIQ_FIFOCLR_OFFSET, WDC_SIZE_16, WDC_READ_WRITE, "FIFOCLR", "" },
    { HIQ_ICLEAR_SPACE, HIQ_ICLEAR_OFFSET, WDC_SIZE_16, WDC_READ_WRITE, "ICLEAR", "" },
    { HIQ_STATUS_SPACE, HIQ_STATUS_OFFSET, WDC_SIZE_16, WDC_READ_WRITE, "STATUS", "" },
    { HIQ_TIMER_CMD_012_SPACE, HIQ_TIMER_CMD_012_OFFSET, WDC_SIZE_8, WDC_WRITE, "TIMER_CMD_012", "" },
    { HIQ_TIMER0_SPACE, HIQ_TIMER0_OFFSET, WDC_SIZE_8, WDC_READ_WRITE, "TIMER0", "" },
    { HIQ_TIMER1_SPACE, HIQ_TIMER1_OFFSET, WDC_SIZE_8, WDC_READ_WRITE, "TIMER1", "" },
    { HIQ_TIMER2_SPACE, HIQ_TIMER2_OFFSET, WDC_SIZE_8, WDC_READ_WRITE, "TIMER2", "" },
    { HIQ_TIMER_CMD_345_SPACE, HIQ_TIMER_CMD_345_OFFSET, WDC_SIZE_8, WDC_WRITE, "TIMER_CMD_345", "" },
    { HIQ_TIMER3_SPACE, HIQ_TIMER3_OFFSET, WDC_SIZE_8, WDC_READ_WRITE, "TIMER3", "" },
    { HIQ_TIMER4_SPACE, HIQ_TIMER4_OFFSET, WDC_SIZE_8, WDC_READ_WRITE, "TIMER4", "" },
    { HIQ_TIMER5_SPACE, HIQ_TIMER5_OFFSET, WDC_SIZE_8, WDC_READ_WRITE, "TIMER5", "" },
    { HIQ_ISTAT_SPACE, HIQ_ISTAT_OFFSET, WDC_SIZE_8, WDC_READ_WRITE, "ISTAT", "" },
    { HIQ_STATUS1_SPACE, HIQ_STATUS1_OFFSET, WDC_SIZE_8, WDC_READ_WRITE, "STATUS1", "" },
    };
const WDC_REG *gpHIQ_Regs = gHIQ_Regs;
#define HIQ_REGS_NUM 10

/*************************************************************
  Functions implementation
 *************************************************************/
DWORD LibInit(void)
{
    WDC_DEVICE_HANDLE hDev = NULL;
    DWORD dwStatus;

    printf("\n");
    printf("HIQ RADAR Receiver Processor.\n");
    printf("Application accesses hardware using " WD_PROD_NAME "\n"
        "and a Kernel PlugIn driver (%s).\n", KP_HIQ_DRIVER_NAME);

    /* Initialize the HIQ library */
    dwStatus = HIQ_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
		if(WD_OPERATION_ALREADY_DONE != dwStatus)
		{
			HIQ_ERR("hiq_diag: Failed to initialize the HIQ library: %s",
            HIQ_GetLastErr());
		}
		return dwStatus;
    }

	return dwStatus;
}


static DWORD Cleanup(WDC_DEVICE_HANDLE hDev)
{
	DWORD dwStatus;
    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);
 
    dwStatus = HIQ_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        HIQ_ERR("hiq_diag: Failed to uninit the HIQ library: %s", HIQ_GetLastErr());
    
    return dwStatus;
}


/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
/* Find and open a HIQ device as a function of device number (0 to N-1) */
WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD deviceNumber, PHIQ_DEV_CTX pHiqDevCtx)
{
    WD_PCI_SLOT slot;
    
    if (!DeviceFind(deviceNumber, &slot))
        return NULL;

    return DeviceOpen(&slot, pHiqDevCtx);
}


/* Find a HIQ device as a function of device number (0 to N-1) */
static BOOL DeviceFind(DWORD deviceNumber, WD_PCI_SLOT *pSlot)
{
	char *self = "DeviceFind:";
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(HIQ_DEFAULT_VENDOR_ID, HIQ_DEFAULT_DEVICE_ID, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        HIQ_ERR("%s Failed scanning the PCI bus.\n"
            "Error: 0x%lx - %s\n", self, dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        HIQ_ERR("%s No HiQ device was found.\n", self);

        return FALSE;
    }
    
    printf("%s Found %ld HiQ device%s.\n", self,
        dwNumDevices, dwNumDevices > 1 ? "s" : "");
    
    for (i = 0; i < dwNumDevices; i++)
    {
    //    WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
		printf("%s Card %i: Bus %i, Slot %i, Function %i found.\n", 
			self, i, 
			scanResult.deviceSlot[i].dwBus,
			scanResult.deviceSlot[i].dwSlot,
			scanResult.deviceSlot[i].dwFunction);
    }

    if (dwNumDevices > 1)
    {
		// HIQ_LocateAndOpen logic
		// KPTODO: maybe not necessary since devicenumber is an arg. Check this.
    }

	// Pass back result.
	printf("%s Returning requested whichhiq card %i.\n", self, deviceNumber);
    *pSlot = scanResult.deviceSlot[deviceNumber];

    return TRUE;
}

/* Open a handle to a HIQ device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT *pSlot, PHIQ_DEV_CTX pHiqDevCtx)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus, dwKPResult = 0;
    WD_PCI_CARD_INFO deviceInfo;
    KP_HIQ_VERSION kpVer;
    
    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        HIQ_ERR("DeviceOpen: Failed retrieving the device's resources information.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: You can modify the device's resources information here, if
       necessary (mainly the deviceInfo.Card.Items array or the items number -
       deviceInfo.Card.dwItems) in order to register only some of the resources
       or register only a portion of a specific address space, for example. */

    /* Open a handle to the device */
    hDev = HIQ_DeviceOpen(&deviceInfo, pHiqDevCtx);
    if (!hDev)
    {
        HIQ_ERR("DeviceOpen: Failed opening a handle to the device: %s",
            HIQ_GetLastErr());
        return NULL;
    }

    /* Get Kernel PlugIn driver version */
    BZERO(kpVer);
    
    dwStatus = WDC_CallKerPlug(hDev, KP_HIQ_MSG_VERSION, &kpVer, &dwKPResult);

    printf("\n");
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        HIQ_ERR("Failed sending a 'Get Version' message (0x%x) to the Kernel PlugIn driver (%s).\n"
            "Error 0x%lx - %s\n",
            KP_HIQ_MSG_VERSION, KP_HIQ_DRIVER_NAME, dwStatus, Stat2Str(dwStatus));
    }
    else if (KP_HIQ_STATUS_OK != dwKPResult)
    {
        HIQ_ERR("Kernel PlugIn 'Get Version' message (0x%x) failed. "
"Kernel PlugIn status: 0x%lx\n", KP_HIQ_MSG_VERSION, dwKPResult);
    }
    else
    {
        printf("Using %s Kernel-Plugin driver version %ld.%02ld - %s\n",
            KP_HIQ_DRIVER_NAME, kpVer.dwVer/100, kpVer.dwVer%100, kpVer.cVer);
    }

    return hDev;
}


/* Close handle to a HIQ device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    if (!hDev)
        return;

    if (!HIQ_DeviceClose(hDev))
    {
        HIQ_ERR("DeviceClose: Failed closing HIQ device: %s",
            HIQ_GetLastErr());
    }
}
