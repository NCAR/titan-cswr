/************************************************************************
*  File: hiq_lib.c
*
*  Library for accessing HIQ devices using a Kernel PlugIn driver.
*  The code accesses hardware using WinDriver's WDC library.
*  Code was generated by DriverWizard v9.20.
*
*  Jungo Confidential. Copyright (c) 2009 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#if defined (__KERNEL__)
    #include "kpstdlib.h"
#else
    #include <stdio.h>
    #include <stdarg.h>
#endif
#include "wdc_defs.h"
#include "utils.h"
#include "status_strings.h"
#include "hiq_lib.h"
#include "hiq_hardware.h"
#include "code_controls.h"
//#include "..\include\smfifo.h"

#define DEBUG

#define DELAY { __asm {add eax, 0} \
				__asm {add eax, 0} \
				__asm {add eax, 0} \
				__asm {add eax, 0} } // do nothing, but delay.

/*************************************************************
  Internal definitions
 *************************************************************/
/* Kernel PlugIn driver name (should be no more than 8 characters) */
#define KP_HIQ_DRIVER_NAME "KP_HIQ"
	/* WinDriver license registration string */
/* TODO: When using a registered WinDriver version, make sure the license string
         below is your specific WinDriver license registration string and set 
 * the driver name to your driver's name */
//#define HIQ_DEFAULT_LICENSE_STRING "6f1eafddaae6b597a9faadec2ae87dece7302e77e9cd1e.Advanced Radar Corporation"	// archiq013
#define HIQ_DEFAULT_LICENSE_STRING "6f1eafddaae6b597a9faadcae759f7d698352fd38b2590.Advanced Radar Corporation"	// arc-015
#define HIQ_DEFAULT_DRIVER_NAME "windrvr6"

static CHAR gsHIQ_LastErr[256];

static DWORD LibInit_count = 0;
/*************************************************************
  Static functions prototypes and inline implementation
 *************************************************************/
#if !defined(__KERNEL__)
static BOOL DeviceValidate(const PWDC_DEVICE pDev);
static void DLLCALLCONV HIQ_IntHandler(PVOID pData);
#endif
static void ErrLog(const CHAR *sFormat, ...);
static void TraceLog(const CHAR *sFormat, ...);

static inline BOOL IsValidDevice(PWDC_DEVICE pDev, const CHAR *sFunc)
{
    if (!pDev || !WDC_GetDevContext(pDev))
    {
        snprintf(gsHIQ_LastErr, sizeof(gsHIQ_LastErr) - 1, "%s: NULL device %s\n",
            sFunc, !pDev ? "handle" : "context");
        ErrLog(gsHIQ_LastErr);
        return FALSE;
    }

    return TRUE;
}

/*************************************************************
  Functions implementation
 *************************************************************/
/* -----------------------------------------------
    HIQ and WDC library initialize/uninit
   ----------------------------------------------- */
DWORD HIQ_LibInit(void)
{
    DWORD dwStatus;

    /* init only once */
    if (++LibInit_count > 1)
        return WD_STATUS_SUCCESS;
 
#if defined(WD_DRIVER_NAME_CHANGE)
    /* Set the driver name */
    if (!WD_DriverName(HIQ_DEFAULT_DRIVER_NAME))
    {
        ErrLog("Failed to set the driver name for WDC library.\n");
        return WD_SYSTEM_INTERNAL_ERROR;
    }
#endif

    /* Set WDC library's debug options (default: level TRACE, output to Debug Monitor) */
    dwStatus = WDC_SetDebugOptions(WDC_DBG_DEFAULT, NULL);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed to initialize debug options for WDC library.\n"
            "Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
        
        return dwStatus;
    }

    /* Open a handle to the driver and initialize the WDC library */
    dwStatus = WDC_DriverOpen(WDC_DRV_OPEN_DEFAULT, HIQ_DEFAULT_LICENSE_STRING);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed to initialize the WDC library. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
        
        return dwStatus;
    }

    return WD_STATUS_SUCCESS;
}

DWORD HIQ_LibUninit(void)
{
    DWORD dwStatus;

    if (--LibInit_count > 0)
        return WD_STATUS_SUCCESS;
 
    /* Uninit the WDC library and close the handle to WinDriver */
    dwStatus = WDC_DriverClose();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed to uninit the WDC library. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
    }

    return dwStatus;
}

#if !defined(__KERNEL__)
/* -----------------------------------------------
    Device open/close
   ----------------------------------------------- */
WDC_DEVICE_HANDLE HIQ_DeviceOpen(const WD_PCI_CARD_INFO *pDeviceInfo, PHIQ_DEV_CTX pMyDevCtx)
{
    DWORD dwStatus;
    PHIQ_DEV_CTX pDevCtx = NULL;
    WDC_DEVICE_HANDLE hDev = NULL;

    /* Validate arguments */
    if (!pDeviceInfo)
    {
        ErrLog("HIQ_DeviceOpen: Error - NULL device information struct pointer\n");
        return NULL;
    }

    /* Allocate memory for the HIQ device context */
    pDevCtx = (PHIQ_DEV_CTX)malloc(sizeof (HIQ_DEV_CTX));
    if (!pDevCtx)
    {
        ErrLog("Failed allocating memory for HIQ device context\n");
        return NULL;
    }

    BZERO(*pDevCtx);

	// Set context so that it is later copied over to the Kernel Plugin.
	*pDevCtx = *pMyDevCtx;

    /* Open a Kernel PlugIn WDC device handle */
    dwStatus = WDC_PciDeviceOpen(&hDev, pDeviceInfo, pDevCtx, NULL, KP_HIQ_DRIVER_NAME, &hDev); // fails with second card

    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed opening a WDC device handle. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
        goto Error;
    }

    /* Validate device information */
    if (!DeviceValidate((PWDC_DEVICE)hDev))
        goto Error;

    /* Return handle to the new device */
    TraceLog("HIQ_DeviceOpen: Opened a HIQ device (handle 0x%p)\n"        
"Device uses a Kernel PlugIn driver (%s)\n", hDev, KP_HIQ_DRIVER_NAME);
    return hDev;

Error:    
    if (hDev)
        HIQ_DeviceClose(hDev);
    else
        free(pDevCtx);
    
    return NULL;
}

BOOL HIQ_DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    PHIQ_DEV_CTX pDevCtx;
    
    TraceLog("HIQ_DeviceClose entered. Device handle: 0x%p\n", hDev);

    if (!hDev)
    {
        ErrLog("HIQ_DeviceClose: Error - NULL device handle\n");
        return FALSE;
    }

    pDevCtx = (PHIQ_DEV_CTX)WDC_GetDevContext(pDev);
    
    /* Disable interrupts */
    if (WDC_IntIsEnabled(hDev))
    {
        dwStatus = HIQ_IntDisable(hDev);
        if (WD_STATUS_SUCCESS != dwStatus)
        {
            ErrLog("Failed disabling interrupts. Error 0x%lx - %s\n",
                dwStatus, Stat2Str(dwStatus));
        }
    }

    /* Close the device */
    dwStatus = WDC_PciDeviceClose(hDev);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed closing a WDC device handle (0x%p). Error 0x%lx - %s\n",
            hDev, dwStatus, Stat2Str(dwStatus));
    }

    /* Free HIQ device context memory */
    if (pDevCtx)
        free (pDevCtx);
    
    return (WD_STATUS_SUCCESS == dwStatus);
}

static BOOL DeviceValidate(const PWDC_DEVICE pDev)
{
    DWORD i, dwNumAddrSpaces = pDev->dwNumAddrSpaces;

    /* TODO: You can modify the implementation of this function in order to
             verify that the device has all expected resources. */
    
    /* Verify that the device has at least one active address space */
    for (i = 0; i < dwNumAddrSpaces; i++)
    {
        if (WDC_AddrSpaceIsActive(pDev, i))
            return TRUE;
    }
    
    ErrLog("Device does not have any active memory or I/O address spaces\n");
    return FALSE;
}

/* -----------------------------------------------
    Interrupts
   ----------------------------------------------- */
static void DLLCALLCONV HIQ_IntHandler(PVOID pData)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)pData;
    PHIQ_DEV_CTX pDevCtx = (PHIQ_DEV_CTX)WDC_GetDevContext(pDev);
    HIQ_INT_RESULT intResult;

	TraceLog("HIQ_IntHandler entered. Device handle: 0x%p\n", (WDC_DEVICE_HANDLE)pDev);
    BZERO(intResult);
    intResult.dwCounter = pDev->Int.dwCounter;
    intResult.dwLost = pDev->Int.dwLost;
    intResult.waitResult = (WD_INTERRUPT_WAIT_RESULT)pDev->Int.fStopped;
    intResult.dwEnabledIntType = WDC_GET_ENABLED_INT_TYPE(pDev);
    intResult.dwLastMessage = WDC_GET_ENABLED_INT_LAST_MSG(pDev);
    
    /* Execute the diagnostics application's interrupt handler routine */
    //pDevCtx->funcIntHandler((WDC_DEVICE_HANDLE)pDev, &intResult);
    pDevCtx->funcIntHandler(pDev, &intResult);
}

static BOOL IsItemExists(PWDC_DEVICE pDev, ITEM_TYPE item)
{
    unsigned int i;
    DWORD dwNumItems = pDev->cardReg.Card.dwItems;

    for (i=0; i<dwNumItems; i++)
    {
        if (pDev->cardReg.Card.Item[i].item == item)
            return TRUE;
    }

    return FALSE;
}

DWORD HIQ_IntEnable(WDC_DEVICE_HANDLE hDev, HIQ_INT_HANDLER funcIntHandler)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    PHIQ_DEV_CTX pDevCtx;

	TraceLog("HIQ_IntEnable entered. Device handle: 0x%p\n", hDev);

    if (!IsValidDevice(pDev, "HIQ_IntEnable"))
        return WD_INVALID_PARAMETER;

    if (!IsItemExists(pDev, ITEM_INTERRUPT))
        return WD_OPERATION_FAILED;

    pDevCtx = (PHIQ_DEV_CTX)WDC_GetDevContext(pDev);

   /* Check if interrupts are already enabled */
    if (WDC_IntIsEnabled(hDev))
    {
        ErrLog("Interrupts are already enabled. Device handle: 0x%p\n", hDev);
        return WD_OPERATION_ALREADY_DONE;
    }

    /* Store the diag interrupt handler routine, which will be executed by
       HIQ_IntHandler() when an interrupt is received */
    pDevCtx->funcIntHandler = funcIntHandler;
    
    /* Enable the interrupts */
    /* NOTE: When adding read transfer commands, set the INTERRUPT_CMD_COPY flag
             in the 4th argument (dwOptions) passed to WDC_IntEnable() */
    dwStatus = WDC_IntEnable(hDev, NULL, 0, 0, HIQ_IntHandler, (PVOID)pDev, WDC_IS_KP(hDev));

    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed enabling interrupts. Device handle: 0x%p. Error 0x%lx - %s\n",
            hDev, dwStatus, Stat2Str(dwStatus));
        
        return dwStatus;
    }

    /* Physically enable the hardware interrupts */
// KPTODO: check if next line is really necessary or breaks something.
//	HIQ_WriteISTAT(hDev, 0);	// Turn off any pending interrupts.
	HIQ_WriteISTAT(hDev, INT_FIFO_HF);	/* enable HF interrupts */
	HIQ_WriteINTCSR(hDev,0x0900);	// enable Interrupt CSR -Lint interrupt.

    TraceLog("HIQ_IntEnable: Interrupts enabled. Device handle: 0x%p.\n", hDev);

    return WD_STATUS_SUCCESS;
}

DWORD HIQ_IntDisable(WDC_DEVICE_HANDLE hDev)
{
    DWORD dwStatus;
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    PHIQ_DEV_CTX pDevCtx;

    TraceLog("HIQ_IntDisable entered. Device handle: 0x%p\n", hDev);

    if (!IsValidDevice(pDev, "HIQ_IntDisable"))
        return WD_INVALID_PARAMETER;

    pDevCtx = (PHIQ_DEV_CTX)WDC_GetDevContext(pDev);
 
    if (!WDC_IntIsEnabled(hDev))
    {
        ErrLog("Interrupts are already disabled ...\n");
        return WD_OPERATION_ALREADY_DONE;
    }

    /* TODO: You can add code here to write to the device in order
             to physically disable the hardware interrupts */
	//*hiq->istat = 0;	/* don't allow any interrupts to go to the PLX chip */
	HIQ_WriteISTAT(hDev, 0);	/* don't allow any interrupts to go to the PLX chip */
	HIQ_WriteINTCSR(hDev, HIQ_ReadINTCSR(hDev) & 0xfffffeff);	// set INTCSR to disable PCI interrupt.

    /* Disable the interrupts */
    dwStatus = WDC_IntDisable(hDev);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        ErrLog("Failed disabling interrupts. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
    }

    return dwStatus;
}

BOOL HIQ_IntIsEnabled(WDC_DEVICE_HANDLE hDev)
{
    if (!IsValidDevice((PWDC_DEVICE)hDev, "HIQ_IntIsEnabled"))
        return FALSE;

    return WDC_IntIsEnabled(hDev);
}

#endif

/* -----------------------------------------------
    Address spaces information
   ----------------------------------------------- */
DWORD HIQ_GetNumAddrSpaces(WDC_DEVICE_HANDLE hDev)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    
    if (!IsValidDevice(pDev, "HIQ_GetNumAddrSpaces"))
        return 0;

    return pDev->dwNumAddrSpaces;
}

BOOL HIQ_GetAddrSpaceInfo(WDC_DEVICE_HANDLE hDev, HIQ_ADDR_SPACE_INFO *pAddrSpaceInfo)
{
    PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
    WDC_ADDR_DESC *pAddrDesc;
    DWORD dwAddrSpace, dwMaxAddrSpace;
    BOOL fIsMemory;
    
    if (!IsValidDevice(pDev, "HIQ_GetAddrSpaceInfo"))
        return FALSE;

#if defined(DEBUG)
    if (!pAddrSpaceInfo)
    {
        ErrLog("HIQ_GetAddrSpaceInfo: Error - NULL address space information pointer\n");
        return FALSE;
    }
#endif

    dwAddrSpace = pAddrSpaceInfo->dwAddrSpace;
    dwMaxAddrSpace = pDev->dwNumAddrSpaces - 1;

    if (dwAddrSpace > dwMaxAddrSpace)
    {
        ErrLog("HIQ_GetAddrSpaceInfo: Error - Address space %ld is out of range (0 - %ld)\n",
            dwAddrSpace, dwMaxAddrSpace);
        return FALSE;
    }

    pAddrDesc = &pDev->pAddrDesc[dwAddrSpace];

    fIsMemory = WDC_ADDR_IS_MEM(pAddrDesc);
    
    snprintf(pAddrSpaceInfo->sName, MAX_NAME - 1, "BAR %ld", dwAddrSpace);
    snprintf(pAddrSpaceInfo->sType, MAX_TYPE - 1, fIsMemory ? "Memory" : "I/O");
        
    if (WDC_AddrSpaceIsActive(pDev, dwAddrSpace))
    {
        WD_ITEMS *pItem = &pDev->cardReg.Card.Item[pAddrDesc->dwItemIndex];
        DWORD dwAddr = fIsMemory ? pItem->I.Mem.dwPhysicalAddr : (DWORD)pItem->I.IO.dwAddr;
        
        snprintf(pAddrSpaceInfo->sDesc, MAX_DESC - 1, "0x%0*lX - 0x%0*lX (0x%lx bytes)",
            (int)WDC_SIZE_32 * 2, dwAddr,
            (int)WDC_SIZE_32 * 2, dwAddr + pAddrDesc->dwBytes - 1,
            pAddrDesc->dwBytes);
    }
    else
        snprintf(pAddrSpaceInfo->sDesc, MAX_DESC - 1, "Inactive address space");

    /* TODO: You can modify the code above to set a different address space name/description */

    return TRUE;
}

// Function: HIQ_ReadINTCSR()
//   Read from INTCSR register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
UINT32 HIQ_ReadINTCSR (WDC_DEVICE_HANDLE hDev)
{
    UINT32 data;

    WDC_ReadAddr32(hDev, HIQ_INTCSR_SPACE, HIQ_INTCSR_OFFSET, &data);
    return data;
}

// Function: HIQ_WriteINTCSR()
//   Write to INTCSR register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void HIQ_WriteINTCSR (WDC_DEVICE_HANDLE hDev, UINT32 data)
{
    WDC_WriteAddr32(hDev, HIQ_INTCSR_SPACE, HIQ_INTCSR_OFFSET, data);
}

// Function: HIQ_ReadDMACSR0()
//   Read from DMACSR0 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadDMACSR0 (WDC_DEVICE_HANDLE hDev)
{
    BYTE data;

    WDC_ReadAddr8(hDev, HIQ_DMACSR0_SPACE, HIQ_DMACSR0_OFFSET, &data);
    return data;
}

// Function: HIQ_WriteDMACSR0()
//   Write to DMACSR0 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void HIQ_WriteDMACSR0 (WDC_DEVICE_HANDLE hDev, BYTE data)
{
    WDC_WriteAddr8(hDev, HIQ_DMACSR0_SPACE, HIQ_DMACSR0_OFFSET, data);
}

// Function: HIQ_ReadDMAPR0()
//   Read from DMAPR0 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
UINT32 HIQ_ReadDMAPR0 (WDC_DEVICE_HANDLE hDev)
{
    UINT32 data;

    WDC_ReadAddr32(hDev, HIQ_DMAPR0_SPACE, HIQ_DMAPR0_OFFSET, &data);
    return data;
}

// Function: HIQ_WriteDMAPR0()
//   Write to DMAPR0 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void HIQ_WriteDMAPR0 (WDC_DEVICE_HANDLE hDev, UINT32 data)
{
    WDC_WriteAddr32(hDev, HIQ_DMAPR0_SPACE, HIQ_DMAPR0_OFFSET, data);
}

// Function: HIQ_ReadDMAMODE0()
//   Read from DMAMODE0 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
UINT32 HIQ_ReadDMAMODE0 (WDC_DEVICE_HANDLE hDev)
{
    UINT32 data;

    WDC_ReadAddr32(hDev, HIQ_DMAMODE0_SPACE, HIQ_DMAMODE0_OFFSET, &data);
    return data;
}

// Function: HIQ_WriteDMAMODE0()
//   Write to DMAMODE0 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void HIQ_WriteDMAMODE0 (WDC_DEVICE_HANDLE hDev, UINT32 data)
{
    WDC_WriteAddr32(hDev, HIQ_DMAMODE0_SPACE, HIQ_DMAMODE0_OFFSET, data);
}

// Function: HIQ_ReadFIFOCLR()
//   Read from FIFOCLR register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadFIFOCLR (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_FIFOCLR_SPACE, HIQ_FIFOCLR_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteFIFOCLR()
//   Write to FIFOCLR register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void HIQ_WriteFIFOCLR (WDC_DEVICE_HANDLE hDev, WORD data)
{
    WDC_WriteAddr16(hDev, HIQ_FIFOCLR_SPACE, HIQ_FIFOCLR_OFFSET, data);
}

// Function: HIQ_ReadICLEAR()
//   Read from ICLEAR register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadICLEAR (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_ICLEAR_SPACE, HIQ_ICLEAR_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteICLEAR()
//   Write to ICLEAR register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void HIQ_WriteICLEAR (WDC_DEVICE_HANDLE hDev, WORD data)
{
    WDC_WriteAddr16(hDev, HIQ_ICLEAR_SPACE, HIQ_ICLEAR_OFFSET, data);
}

// Function: HIQ_ReadSTATUS()
//   Read from STATUS register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
WORD HIQ_ReadSTATUS (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_STATUS_SPACE, HIQ_STATUS_OFFSET, &data);
    return data;
}

// Function: HIQ_WriteSTATUS()
//   Write to STATUS register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void HIQ_WriteSTATUS (WDC_DEVICE_HANDLE hDev, WORD data)
{
    WDC_WriteAddr16(hDev, HIQ_STATUS_SPACE, HIQ_STATUS_OFFSET, data);
}

// Function: HIQ_ReadISTAT()
//   Read from ISTAT register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadISTAT (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_ISTAT_SPACE, HIQ_ISTAT_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteISTAT()
//   Write to ISTAT register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void HIQ_WriteISTAT (WDC_DEVICE_HANDLE hDev, WORD data)
{
    WDC_WriteAddr16(hDev, HIQ_ISTAT_SPACE, HIQ_ISTAT_OFFSET, data);
}

// Function: HIQ_ReadSTATUS1()
//   Read from STATUS1 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadSTATUS1 (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_STATUS1_SPACE, HIQ_STATUS1_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteSTATUS1()
//   Write to STATUS1 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
void HIQ_WriteSTATUS1 (WDC_DEVICE_HANDLE hDev, WORD data)
{
    WDC_WriteAddr16(hDev, HIQ_STATUS1_SPACE, HIQ_STATUS1_OFFSET, data);
}

// Function: HIQ_WriteTIMER_CMD_012()
//   Write to TIMER_CMD_012 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
DWORD HIQ_WriteTIMER_CMD_012 (WDC_DEVICE_HANDLE hDev, WORD data)
{
	DELAY;
    WDC_WriteAddr16(hDev, HIQ_TIMER_CMD_012_SPACE, HIQ_TIMER_CMD_012_OFFSET, data);
	return (((PWDC_DEVICE)hDev)->pAddrDesc[HIQ_TIMER_CMD_012_SPACE].dwUserDirectMemAddr)+HIQ_TIMER_CMD_012_OFFSET;
}

// Function: HIQ_WriteTIMER_CMD_345()
//   Write to TIMER_CMD_345 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
DWORD HIQ_WriteTIMER_CMD_345 (WDC_DEVICE_HANDLE hDev, WORD data)
{
	DELAY;
    WDC_WriteAddr16(hDev, HIQ_TIMER_CMD_345_SPACE, HIQ_TIMER_CMD_345_OFFSET, data);
	return (((PWDC_DEVICE)hDev)->pAddrDesc[HIQ_TIMER_CMD_345_SPACE].dwUserDirectMemAddr)+HIQ_TIMER_CMD_345_OFFSET;
}

// Function: HIQ_ReadTIMER0()
//   Read from TIMER0 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadTIMER0 (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_TIMER0_SPACE, HIQ_TIMER0_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteTIMER0()
//   Write to TIMER0 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
DWORD HIQ_WriteTIMER0 (WDC_DEVICE_HANDLE hDev, WORD data)
{
	DELAY;
    WDC_WriteAddr16(hDev, HIQ_TIMER0_SPACE, HIQ_TIMER0_OFFSET, data);
	return (((PWDC_DEVICE)hDev)->pAddrDesc[HIQ_TIMER0_SPACE].dwUserDirectMemAddr)+HIQ_TIMER0_OFFSET;

}

// Function: HIQ_ReadTIMER1()
//   Read from TIMER1 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadTIMER1 (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_TIMER1_SPACE, HIQ_TIMER1_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteTIMER1()
//   Write to TIMER1 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
DWORD HIQ_WriteTIMER1 (WDC_DEVICE_HANDLE hDev, WORD data)
{
	DELAY;
    WDC_WriteAddr16(hDev, HIQ_TIMER1_SPACE, HIQ_TIMER1_OFFSET, data);
	return (((PWDC_DEVICE)hDev)->pAddrDesc[HIQ_TIMER1_SPACE].dwUserDirectMemAddr)+HIQ_TIMER1_OFFSET;
}

// Function: HIQ_ReadTIMER2()
//   Read from TIMER2 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadTIMER2 (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_TIMER2_SPACE, HIQ_TIMER2_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteTIMER2()
//   Write to TIMER2 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
DWORD HIQ_WriteTIMER2 (WDC_DEVICE_HANDLE hDev, WORD data)
{
	DELAY;
    WDC_WriteAddr16(hDev, HIQ_TIMER2_SPACE, HIQ_TIMER2_OFFSET, data);
	return (((PWDC_DEVICE)hDev)->pAddrDesc[HIQ_TIMER2_SPACE].dwUserDirectMemAddr)+HIQ_TIMER2_OFFSET;
}

// Function: HIQ_ReadTIMER3()
//   Read from TIMER3 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadTIMER3 (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_TIMER3_SPACE, HIQ_TIMER3_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteTIMER3()
//   Write to TIMER3 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
DWORD HIQ_WriteTIMER3 (WDC_DEVICE_HANDLE hDev, WORD data)
{
	DELAY;
    WDC_WriteAddr16(hDev, HIQ_TIMER3_SPACE, HIQ_TIMER3_OFFSET, data);
	return (((PWDC_DEVICE)hDev)->pAddrDesc[HIQ_TIMER3_SPACE].dwUserDirectMemAddr)+HIQ_TIMER3_OFFSET;
}

// Function: HIQ_ReadTIMER4()
//   Read from TIMER4 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadTIMER4 (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_TIMER4_SPACE, HIQ_TIMER4_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteTIMER4()
//   Write to TIMER4 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
DWORD HIQ_WriteTIMER4 (WDC_DEVICE_HANDLE hDev, WORD data)
{
	DELAY;
    WDC_WriteAddr16(hDev, HIQ_TIMER4_SPACE, HIQ_TIMER4_OFFSET, data);
	return (((PWDC_DEVICE)hDev)->pAddrDesc[HIQ_TIMER4_SPACE].dwUserDirectMemAddr)+HIQ_TIMER4_OFFSET;
}

// Function: HIQ_ReadTIMER5()
//   Read from TIMER5 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
// Return Value:
//   The value read from the register.
BYTE HIQ_ReadTIMER5 (WDC_DEVICE_HANDLE hDev)
{
    WORD data;

    WDC_ReadAddr16(hDev, HIQ_TIMER5_SPACE, HIQ_TIMER5_OFFSET, &data);
    return (BYTE)data;
}

// Function: HIQ_WriteTIMER5()
//   Write to TIMER5 register.
// Parameters:
//   hDev [in] handle to the card as received from HIQ_DeviceOpen().
//   data [in] the data to write to the register.
// Return Value:
//   None.
DWORD HIQ_WriteTIMER5 (WDC_DEVICE_HANDLE hDev, WORD data)
{
	DELAY;
    WDC_WriteAddr16(hDev, HIQ_TIMER5_SPACE, HIQ_TIMER5_OFFSET, data);
	return (((PWDC_DEVICE)hDev)->pAddrDesc[HIQ_TIMER5_SPACE].dwUserDirectMemAddr)+HIQ_TIMER5_OFFSET;
}

/* -----------------------------------------------
    Debugging and error handling
   ----------------------------------------------- */
static void ErrLog(const CHAR *sFormat, ...)
{
    va_list argp;
    va_start(argp, sFormat);
    vsnprintf(gsHIQ_LastErr, sizeof(gsHIQ_LastErr) - 1, sFormat, argp);
#if defined(DEBUG)
#if defined (__KERNEL__)
    WDC_Err("KP HIQ lib: %s", HIQ_GetLastErr());
#else
    WDC_Err("HIQ lib: %s", HIQ_GetLastErr());
#endif
#endif
    va_end(argp);
}

static void TraceLog(const CHAR *sFormat, ...)
{
#if defined(DEBUG)
    CHAR sMsg[256];
    va_list argp;
    va_start(argp, sFormat);
    vsnprintf(sMsg, sizeof(sMsg) - 1, sFormat, argp);
#if defined (__KERNEL__)
    WDC_Trace("KP HIQ lib: %s", sMsg);
#else
    WDC_Trace("HIQ lib: %s", sMsg);
#endif
    va_end(argp);
#endif
}

const char *HIQ_GetLastErr(void)
{
    return gsHIQ_LastErr;
}

// Customizations for testing in HIQ env

/* program the HIQ timer chips with chip specific parameters */
//void HIQ_timer(int timernum,int timermode,int count,int whichhiq)
void HIQ_timer(int timernum, int timermode, int count, WDC_DEVICE_HANDLE hDev)
{
	// Load timer command.
	char *self = "HIQ_timer";
	WORD writeCmd;
	PWDC_DEVICE pDev = (PWDC_DEVICE)hDev;
	DWORD addrC, addrL, addrH = 0;
	int timerValue = timernum;	// For timer cmd computation.

	// debug
	int readVal = 0;
/*
	WDC_ADDR_DESC ADC012 = pDev->pAddrDesc[HIQ_TIMER_CMD_012_SPACE];
	WDC_ADDR_DESC ADC345 = pDev->pAddrDesc[HIQ_TIMER_CMD_345_SPACE];
	WDC_ADDR_DESC ADT0 = pDev->pAddrDesc[HIQ_TIMER0_SPACE];
	WDC_ADDR_DESC ADT1 = pDev->pAddrDesc[HIQ_TIMER1_SPACE];
	WDC_ADDR_DESC ADT2 = pDev->pAddrDesc[HIQ_TIMER2_SPACE];
	WDC_ADDR_DESC ADT3 = pDev->pAddrDesc[HIQ_TIMER3_SPACE];
	WDC_ADDR_DESC ADT4 = pDev->pAddrDesc[HIQ_TIMER4_SPACE];
	WDC_ADDR_DESC ADT5 = pDev->pAddrDesc[HIQ_TIMER5_SPACE];
	WDC_ADDR_DESC ADS0 = pDev->pAddrDesc[HIQ_STATUS_SPACE];
	WDC_ADDR_DESC ADS1 = pDev->pAddrDesc[HIQ_STATUS1_SPACE];
	WDC_ADDR_DESC ADIS = pDev->pAddrDesc[HIQ_ISTAT_SPACE];
	WDC_ADDR_DESC *pAD = WDC_GET_ADDR_DESC(pDev,HIQ_TIMER_CMD_012_SPACE);
*/


	// Test adx space
	if(!WDC_AddrSpaceIsActive(hDev, HIQ_TIMER_CMD_012_SPACE))
	{
		TraceLog("***************************************************\n");
		TraceLog("******** Bad timer adx space! Exiting... **********\n");
		TraceLog("***************************************************\n");
		return;
	}
	
	//TraceLog("%s: Enter.\n",self); 

	if(timernum < 0 || timernum > 5)	// {0,1,2} & {3,4,5} are valid timers.
	{
		ErrLog("%s: invalid timernum '%d'\n",self,timernum); 
		return;
	}
	if(timermode < 0 || timermode > 5)
	{
		ErrLog("%s: invalid timermode '%d'\n",self,timermode); 
		return;
	}

	// Load timer command.
	if(timernum > 2)
	{
		timerValue -= 3;	// For timer cmd computation, as M.Randall did it.
	}	
	writeCmd = 0x30 + timerValue * 0x40 + timermode * 2;	// See the 82C54 spec sheet
	if(timernum < 3)
	{
		addrC = HIQ_WriteTIMER_CMD_012 (hDev, writeCmd );
	}
	else if(timernum > 2)
	{
		addrC = HIQ_WriteTIMER_CMD_345 (hDev, writeCmd );
	}
	else
	{
		ErrLog("%s: SW Error. Bad timernum: 0x%lx\n", self, timernum);
		return;
	}

	// Load new count.
	switch(timernum)
	{
		case 0:
			addrL = HIQ_WriteTIMER0 (hDev, (WORD)count);		// write LSByte.
			addrH = HIQ_WriteTIMER0 (hDev, (WORD)(count >> 8));	// write MSByte.
			//readVal = HIQ_ReadTIMER0 (hDev);
			break;
		case 1:
			addrL = HIQ_WriteTIMER1 (hDev, (WORD)count);
			addrH = HIQ_WriteTIMER1 (hDev, (WORD)(count >> 8));
			break;
		case 2:
			addrL = HIQ_WriteTIMER2 (hDev, (WORD)count);
			addrH = HIQ_WriteTIMER2 (hDev, (WORD)(count >> 8));
			break;
		case 3:
			addrL = HIQ_WriteTIMER3 (hDev, (WORD)count);
			addrH = HIQ_WriteTIMER3 (hDev, (WORD)(count >> 8));
			break;
		case 4:
			addrL = HIQ_WriteTIMER4 (hDev, (WORD)count);
			addrH = HIQ_WriteTIMER4 (hDev, (WORD)(count >> 8));
			break;
		case 5:
			addrL = HIQ_WriteTIMER5 (hDev, (WORD)count);
			addrH = HIQ_WriteTIMER5 (hDev, (WORD)(count >> 8));
			break;
		default:
			ErrLog("%s:SW Error. Bad timernum: 0x%lx\n", self, timernum);
			break;
	}
	// tell user which timer and exact counts
	TraceLog("%s:Timer#='%d', mode='%2x', cnt='%4x'(%4d), cmd='0x%2x', Device:'0x%p', C adx='0x%8x', L adx='0x%8x', H adx='0x%8x'.",self,timernum,timermode,count,count,writeCmd,hDev,addrC,addrL,addrH);
	//TraceLog("%s: Exit.\n",self); 
	return;
}
